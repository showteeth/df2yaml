df <- data.frame(name = c("bob","joe"),
                 target = c("yellow", "grey"),
                 code1 = c("fly", "walk"),
                 code2 = c("jump", "run"))
library(yaml)
out <- as.yaml(list(samples=split(replace(df, "name", NULL), df$name)))


selected_steps = c("fe", "wgcna")
basic_paras = read.table(file = 'comorap/all_step_paras.txt', header = T, sep = "\t")

if(length(selected_steps) == 0){
  # shinyalert("Empty detected!", "No steps selected!", 
  #            confirmButtonText = "OK", type = "warning")
  message("No steps selected!")
}else{
  key_paras = basic_paras %>% 
    dplyr::filter(steps %in% selected_steps)
  # check duplicated parameters
  ## get duplicated parameters
  key_dup_paras = subset(key_paras,duplicated(paras))[,"paras"]
  ## prepare valid duplicated parameters dataframe
  key_dup_paras_list=list()
  for (dp in key_dup_paras){
    key_paras_dp_values = unique(key_paras[key_paras$paras == dp,"values"])
    key_paras_dp_stpes = key_paras[key_paras$paras == dp,"steps"]
    # duplicate parameters have different values
    if(length(key_paras_dp_values)>=2){
      if(("" %in% key_paras_dp_values) & (length(key_paras_dp_values)==2)){
        key_dup_paras_list[[dp]] = key_paras[key_paras$paras == dp,] %>% 
          dplyr::filter(values != "")
      }
      # shinyalert("Conflict detected!", paste0(dp, " have different values in: ", paste0(key_paras_dp_stpes, collapse = ", ")), 
      #            confirmButtonText = "OK", type = "warning")
      message(paste0(dp, " have different values in: ", paste0(key_paras_dp_stpes, collapse = ", ")))
    }else if(key_paras_dp_values==""){
      # duplicated parameters have empty values
      message(paste0(dp, " have empty values in: ", paste0(key_paras_dp_stpes, collapse = ", ")))
    }else{
      # duplicated parameters have same non-empty parameters
      key_dup_paras_list[[dp]] = key_paras[key_paras$paras == dp,] %>% 
        dplyr::distinct(.keep_all = T, paras)
    }
  }
  key_dup_paras_df = do.call(rbind, key_dup_paras_list) %>% as.data.frame()
  # non-duplicate parameters
  key_nondup_paras_df = key_paras %>% 
    dplyr::filter(! paras %in% key_dup_paras)
  ## empty paras
  key_nondup_paras_df_empty = key_nondup_paras_df %>% 
    dplyr::filter(values == "")
  if(nrow(key_nondup_paras_df_empty)>0){
    message(paste0(paste0(key_nondup_paras_df_empty$paras, collapse = ", "), " have empty values in: ", 
                   paste0(key_nondup_paras_df_empty$steps, collapse = ", ")))
  }
  ## non-empty paras
  key_nondup_paras_df_nonempty = key_nondup_paras_df %>% 
    dplyr::filter(values != "")
  # get other parameters
  optional_paras = basic_paras %>% 
    dplyr::filter(! steps %in% selected_steps) %>% 
    dplyr::filter(! paras %in% key_dup_paras_df$paras)
  # final dataframe
  final_paras = rbind(key_dup_paras_df, key_nondup_paras_df_nonempty, optional_paras) %>% as.data.frame()
}

selected_steps = c("bamqc", "snv")
soft_paras = read.table(file = 'comorap/all_soft_paras.txt', header = T, sep = "\t")
soft_paras_new = soft_paras %>% 
  dplyr::mutate(paras = ifelse(subcmd!="",paste(paras, subcmd, sep = "__"), paras)) %>% 
  dplyr::select(-subcmd)

# 不是所有的参数都是重要的，比如，如果在构建index的方法时选择了star的话，参数的配置就不一样
library(tidyverse)
basic_paras = read.table(file = 'comorap/all_step_paras.txt', header = T, sep = "\t")

basic_paras = basic_paras %>% 
  dplyr::mutate(newparas=paste(steps, paras,sep = "_"))



# MakeYAML
library(tidyverse)
library(yaml)
library(rrapply)

df2yaml(df = basic_paras, key_col = "paras")
df2yaml(df = soft_paras, out_yaml = "soft_paras.yaml")

CheckColumns=function(df, col){
  if (!all( col %in% colnames(df))){
    invalid_col = setdiff(col, colnames(df))
    stop(paste0(invalid_col, " not in given dataframe. Please check!"))
  }
}

df2yaml = function(df, key_col = c("paras", "subcmd"), val_col = "values", 
                   val_sep = ";", key_sep=":", out_yaml=NULL){
  # check columns
  CheckColumns(df, c(key_col, val_col))
  df = df[c(key_col, val_col)]
  # check duplicates
  df_dup = df[duplicated(df[,key_col]),]
  # remove duplicates
  if(nrow(df_dup)>0){
    warning("Detect duplicated key values, we will keep the first!")
    df_valid = df[!duplicated(df[,key_col]),]
  }else{
    df_valid = df
  }
  # sort the data
  df_valid = df_valid %>% dplyr::arrange(.data[[key_col[1]]])
  
  if(length(key_col) == 1){
    # split to list
    df_valid_li = split(x = df_valid[, val_col], f = df_valid[,key_col])
    if(!is.null(val_sep)){
      if(is.null(key_sep)){
        stop("Require key separator!")
      }
      # split valie
      for (ln in names(df_valid_li)){
        ln_value = df_valid_li[[ln]]
        if(grepl(pattern = ":", x = ln_value)){
          ln_value_vec = strsplit(x = ln_value, split = paste0("[ ]*", val_sep, "[ ]*"))[[1]]
          ln_value_tmp = lapply(ln_value_vec, function(x){strsplit(x = x, split = paste0("[ ]*", key_sep, "[ ]*"))[[1]]}) %>% 
            as.data.frame() %>% t() %>% as.data.frame()
          rownames(ln_value_tmp) = NULL
          ln_value_li = ln_value_tmp %>% tibble::column_to_rownames(var = "V1") %>% t() %>% as.data.frame() %>% as.list()
          df_valid_li[[ln]] = ln_value_li
        }
      }
    }
    # convert to yaml
    df_valid_yaml = as.yaml(df_valid_li)
    # remove possible '
    df_valid_yaml = gsub(pattern = "'", replacement = "", df_valid_yaml)
  }else if(length(key_col) == 2){
    # seperate df according to levels
    df_valid_1 = df_valid[df_valid[, key_col[length(key_col)]]=="", ]
    df_valid_2 = df_valid[df_valid[, key_col[length(key_col)]]!="", ]
    # split to list
    df_valid_1_li = split(x = df_valid_1[, val_col], f = df_valid_1[,key_col[1]])
    df_valid_2_li = rrapply::rrapply(df_valid_2, how = "unmelt")
    if(!is.null(val_sep)){
      if(is.null(key_sep)){
        stop("Require key separator!")
      }
      # split valie
      for (l1n in names(df_valid_1_li)){
        l1n_value = df_valid_1_li[[l1n]]
        if(grepl(pattern = ":", x = l1n_value)){
          l1n_value_vec = strsplit(x = l1n_value, split = paste0("[ ]*", val_sep, "[ ]*"))[[1]]
          l1n_value_tmp = lapply(l1n_value_vec, function(x){strsplit(x = x, split = paste0("[ ]*", key_sep, "[ ]*"))[[1]]}) %>% 
            as.data.frame() %>% t() %>% as.data.frame()
          rownames(l1n_value_tmp) = NULL
          l1n_value_li = l1n_value_tmp %>% tibble::column_to_rownames(var = "V1") %>% t() %>% as.data.frame() %>% as.list()
          df_valid_1_li[[l1n]] = l1n_value_li
        }
      }
    }
    # convert to yaml
    df_valid_1_yaml = as.yaml(df_valid_1_li)
    # remove possible '
    df_valid_1_yaml = gsub(pattern = "'", replacement = "", df_valid_1_yaml)
    if(!is.null(val_sep)){
      if(is.null(key_sep)){
        stop("Require key separator!")
      }
      # split valie
      for (l2n in names(df_valid_2_li)){
        l2n_li = df_valid_2_li[[l2n]]
        for (ll2n in names(l2n_li)){
          l2n_value = l2n_li[[ll2n]]
          if(grepl(pattern = ":", x = l2n_value)){
            l2n_value_vec = strsplit(x = l2n_value, split = "[ ]*;[ ]*")[[1]]
            l2n_value_tmp = lapply(l2n_value_vec, function(x){strsplit(x = x, split = "[ ]*:[ ]*")[[1]]}) %>% 
              as.data.frame() %>% t() %>% as.data.frame()
            rownames(l2n_value_tmp) = NULL
            l2n_value_li = l2n_value_tmp %>% tibble::column_to_rownames(var = "V1") %>% t() %>% as.data.frame() %>% as.list()
            l2n_li[[ll2n]] = l2n_value_li
          }
        }
        df_valid_2_li[[l2n]] = l2n_li
      }
    }
    
    # convert to yaml
    df_valid_2_yaml = as.yaml(df_valid_2_li)
    # remove possible '
    df_valid_2_yaml = gsub(pattern = "'", replacement = "", df_valid_2_yaml)
    # merge
    df_valid_yaml = paste0(df_valid_1_yaml, df_valid_2_yaml) 
  }else{
    stop("The length of key_col is bigger than 2!")
  }
  if(is.null(out_yaml)){
    write(x = df_valid_yaml, file = "df2yaml.yaml")
  }else{
    write(x = df_valid_yaml, file = out_yaml)
  }
}


# update:
# 对于多层嵌套的情况：首先将其拆分为相同的层级，然后去掉这个层级的一列全为空的
# 然后使用rrapply

# * 去掉除了key_col、val_col之外的所有列
# 

# 去除列值全为空的列
test_data = test_data %>%
  select(where(~ any(. != "")))
# 转化为list，然后拆分value
test_data_li = rrapply::rrapply(test_data, how = "unmelt")
test_final = rrapply(
  object = test_data_li, 
  f = function(x) {
    if(grepl(pattern = ":", x = x)){
      x_vec = strsplit(x = x, split = paste0("[ ]*", ";", "[ ]*"))[[1]]
      x_tmp = lapply(x_vec, function(x){strsplit(x = x, split = paste0("[ ]*", ":", "[ ]*"))[[1]]}) %>% 
        as.data.frame() %>% t() %>% as.data.frame()
      rownames(x_tmp) = NULL
      x_li = x_tmp %>% tibble::column_to_rownames(var = "V1") %>% t() %>% as.data.frame() %>% as.list()
      x_li
    }else{
      x
    }
  },  
  how = "replace"
)




      